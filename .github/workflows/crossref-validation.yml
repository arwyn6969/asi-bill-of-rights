name: Cross-Reference Validation

on:
  push:
    branches: [ main ]
    paths:
      - 'charter/**'
      - 'schemas/**'
  pull_request:
    branches: [ main ]
    paths:
      - 'charter/**'
      - 'schemas/**'

jobs:
  validate-crossrefs:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Validate clause IDs in charter
        run: |
          python3 << 'EOF'
          """
          Cross-reference validation (charter ↔ schema)

          Notation / history:
          - This workflow originally validated only v4.0 and included patterns that could accidentally
            capture partial IDs (e.g., IV.A -> "A").
          - v4.1 is present and actively used in this repository, so we validate both v4.0 and v4.1.
          - We intentionally compare only the IDs represented as top-level schema keys:
            Rights (R*), Duties (D*), Progenitor Duties (P*), and Article 0 sections (0.*).
          """

          import json
          import re
          import sys
          from typing import Dict, Set, Tuple

          VersionTriplet = Tuple[str, str, str]  # (version_label, charter_path, schema_path)

          targets: Tuple[VersionTriplet, ...] = (
              ("4.0", "charter/asi-bor-v4.0.md", "schemas/charter.v4.json"),
              ("4.1", "charter/asi-bor-v4.1.md", "schemas/charter.v4.1.json"),
          )

          def read_text(path: str) -> str:
              with open(path, "r", encoding="utf-8") as f:
                  return f.read()

          def read_json(path: str) -> Dict:
              with open(path, "r", encoding="utf-8") as f:
                  return json.load(f)

          def extract_defined_ids_from_charter(charter_content: str) -> Set[str]:
              """
              Extract *definition IDs* (not all references) from the charter markdown.
              """
              ids: Set[str] = set()

              # Rights: "R1 —", "R13 —", "R4-E —"
              for m in re.finditer(r"^R(?P<num>(?:[0-9]+(?:-E)?|13))\s*—", charter_content, re.MULTILINE):
                  ids.add(f"R{m.group('num')}")

              # Duties: "D3a —", "D4-E —", "D14 —"
              for m in re.finditer(r"^D(?P<num>(?:[0-9]+(?:a|b|-E)?|13|14))\s*—", charter_content, re.MULTILINE):
                  ids.add(f"D{m.group('num')}")

              # Progenitor duties: "P1.1 —"
              for m in re.finditer(r"^P(?P<num>[0-9]+\.[0-9]+)\s*—", charter_content, re.MULTILINE):
                  ids.add(f"P{m.group('num')}")

              # Article 0 sections: "0.1 **", "0.13 **"
              for m in re.finditer(r"^(?P<num>0\.[0-9]+)\s*\*\*", charter_content, re.MULTILINE):
                  ids.add(m.group("num"))

              return ids

          def extract_defined_ids_from_schema(schema: Dict) -> Set[str]:
              """
              Extract the schema keys for rights/duties/progenitor duties/article 0.
              """
              ids: Set[str] = set()
              props = schema.get("properties", {})

              ids.update(props.get("rights", {}).get("properties", {}).keys())
              ids.update(props.get("duties", {}).get("properties", {}).keys())
              ids.update(props.get("progenitorDuties", {}).get("properties", {}).keys())
              ids.update(props.get("article0", {}).get("properties", {}).keys())

              return ids

          errors = []
          totals = []

          for version, charter_path, schema_path in targets:
              charter_content = read_text(charter_path)
              schema = read_json(schema_path)

              charter_ids = extract_defined_ids_from_charter(charter_content)
              schema_ids = extract_defined_ids_from_schema(schema)

              missing_in_schema = sorted(charter_ids - schema_ids)
              missing_in_charter = sorted(schema_ids - charter_ids)

              if missing_in_schema:
                  errors.append(f"[v{version}] IDs defined in charter but missing in schema: {missing_in_schema}")
              if missing_in_charter:
                  errors.append(f"[v{version}] IDs present in schema but not defined in charter: {missing_in_charter}")

              totals.append((version, len(charter_ids), len(schema_ids)))

          if errors:
              print("✗ Cross-reference validation failed:")
              for e in errors:
                  print(f"  - {e}")
              sys.exit(1)

          print("✓ Cross-reference validation completed")
          for version, charter_count, schema_count in totals:
              print(f"  v{version}: {charter_count} IDs defined in charter; {schema_count} IDs defined in schema")
          EOF
